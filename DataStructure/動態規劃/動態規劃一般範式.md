å
1. 確定dp[i][j]含義
2. 遞推公式
3. dp數組初始化
4. 遍歷順序
5. 打印數組

## 斐波那契數列

因爲上述的每一步都不是需要思考得到的。都是題給的
## 爬樓梯

先考慮遞歸的辦法。

1. `dp[i]`表示到達i階有`dp[i]`種辦法。
2. `dp[i] = dp[i-1] + dp[i-2]`。
3. 初始化1,2。
4. 從前往後，根據遞推公式。

### 爬樓梯多階版

一次可以爬m階樓梯

### 爬樓梯消費版

1. 到達i位置花費為`dp[i]`
2. `dp[i] = min(dp[i-1] + cost(i-1), dp[i-2] + cost(i-2))`
3. 從前往後，由遞推關係得到
4. 初始化

## 路徑

1. `dp[i][j]`表示從(0,0)走到(i,j) **有多少種不同的路徑**，而不是**多少步**
2. `dp[i][j] = dp[i][j-1] + dp[i-1][j]`
3. `dp[i][0] = dp[0][j] = 1`，只有一種走法
4. 從前往後
> `dp[j][i] = dp[j][i - 1] + dp[j - 1][i];` 注意，這道題沒有遍歷順序。但是調換順序時要注意矩陣的下標全部都要一同調換。不能只調換部分。
### 不同路徑-障礙版

初始化：
`dp[i][0]`和`dp[0][j]`中有障礙，後續的就是0。因爲壓根走不到
遞推公式：
判斷當前位置是否是障礙，**`dp[i][j]`不是障礙才更新dp**

## 拆數乘積

將一個數拆成幾個數的和，讓這個和的乘積最大

1. `dp[i]`表示拆分i得到最大的乘積為`dp[i]`
2. `dp[i] = max(j * dp[i-j], dp[i], j * (i-j))`   $j \ \in [0,i)$
> 將i拆成j,i-j。要麽取自身，要麽i-j繼續拆，要麽就是j * (i-j)
> 遞推方程的意義就是在這裏。遞推方程就是狀態轉移方程
3. `dp[0] = dp[1] = 0; dp[2] = 1`
4. 遍歷順序：從3開始到n

## 二叉搜索樹

給n個節點，返回他們可以組成多少個不同的二叉搜索樹

1. `dp[i]`表示i個節點可以組成`dp[i]`個不同的二叉搜索樹
2. `dp[i] = sum(dp[j-1] * dp[i-j])`  $j \in [0,i)$ j表示已j為頭節點的情況。那麽左子樹有j-1個節點，右字樹有i-j個節點
> 從小規模問題開始畫圖枚舉，發現節點數目很小的時候，很容易枚舉出來“遞歸終止條件”，然後找到大規模和小規模的一般關係。
> 這個問題中，二叉樹就有左右二分。然後枚舉出來`dp[3]`的轉移方程

3. 只初始化`dp[0]=1`即可
4. 從小到大，顯然



