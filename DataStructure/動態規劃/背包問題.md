# 01背包

n種物品，每個物品只有一個，拿不拿。要在背包的限制下拿最多的價值物品

1. `dp[i][j]`表示**容量為j**的背包，在**前i個物品**中能拿下最多的價值
	- 不放物品i：`dp[i][j] = dp[i-1][j]`
	- 放物品i：`dp[i][j] = dp[i-1][j-w[i]] + v[i]`
> 我漏了`j-w[i]`

> 複雜的動態規劃的遞推，或者説狀態轉移是有著更加複雜的結構，他本質上用一個$n^2$的關係矩陣來存下$n!$種關係

2. 遞推公式：`dp[i][j] = max(dp[i-1][j], dp[i-1][j - w[i]] + v[i]);`
3. 初始化，考慮矩陣的初始列：
	- `dp[i][0]`背包容量為0，全部初始化為0。什麽都拿不了
	- `dp[0][j]`只有一個物品，能拿就拿走。具體根據`w[j]`的容量來看的。這就是具體問題具體分析了
	- 其他元素的初始化呢？答案是隨便。考慮遞推方程，遞推方程類似與這樣：`dp[i] = max(dp[i], ...)`需要考慮自身的初始化。但是這裏的`dp[i][j]`完全由其他值計算得到，自己初始化多少都可以。
4.  遍歷順序：考慮狀態轉移方程，`dp[i][j]`從左上更新而來，從左上更新到右下。此外，先遍歷背包還是先遍歷物品都可以。

# 滾動數組

壓縮矩陣的一個維度
壓縮i維度，也就是行維度。

> 爲什麽可以壓縮行？因爲從行的角度來看遞推公式，`dp[i]`都是從`dp[i-1]`更新來的。所以從行來看，每次都是從上一行拷貝下來。不需要記錄所有行。

2. 遞推關系 `dp[j] = max(dp[j], dp[j - w[i]] + v[i])`
3. 初始化：`dp[0]` 當然就是0。`dp[i]`就不能像二維數組那樣玩了。理由在上面的3中，這裏的遞推公式要比較自己，如果隨便取一個很大的數，那麽這個大數就會覆蓋掉所有的值。有兩種辦法。一種辦法是將二維數組第一行搬下來，第二種就全部初始化為0。也就是啥也不拿。
4. 遍歷順序：遍歷物品，遍歷背包。
	- 背包一定要倒序遍歷！因爲滾動數組會修改數組的值，順序遍歷一定會重複取物品的！


> 考慮遞推公式，如果順序遍歷，`dp[j]`是由自己和之前的`dp[j - w[i]] + v[i]`更新來的，那麽`dp[j]`自己肯定幹不過之前的`dp[j - w[i]] + v[i]`,這些`v[i]`被重複添加了好多次。
> 倒序遍歷可以解決這個問題。
> 
> 爲什麽二維dp沒有這個問題？二維dp的數據都是分離的，每一行不會相互影響。當前i行的數據完全由i-1行更新，而不是像一維數組那樣，只有一行，那麽就不是由i-1行更新，而是由這一行的0-j更新。（如果是順序遍歷的話）
> 
> 倒敘遍歷本質上是模擬了一個二維dp的第i-1行，因爲對於`dp[j]`來説，他是從i-1行的0-j更新而來。我們倒序遍歷，對於每一個`dp[j]`他所看到的`dp[j-w[i]]`是上一行的數據。






# 二分子集問題

一個集合，找到一個子集，子集的和是全集和的一半

>半和子集問題就是01背包
>**拿還是不拿問題**


一個集合，裏面的每一個數的價值和重量都是這個數。
`dp[sum/2] == sum/2`  就表示裝滿了

1. `dp[j]`容量為j的背包所背的最大價值為`dp[j]`
2. 遞推方程：`dp[j] = max(dp[j], dp[j - nums[i]] + nums[i])`
3. 初始化：`dp[j]=0` 。全部為0
4. 遍歷順序也就是上面背包的順序。但是第二層循環，注意:

```cpp
for(int i = 0; i < n; i++)
{
	for(int j = sum/2; j >= nums[i]; j--)
	{
		// ...
	}
}
```
背包的最大值就是數組和的一半。背包容量等於當前物品的重量就可以停止了。因爲當前物品他壓根就裝不下，還遍歷啥啊。


# 最後一塊石頭重量

石頭兩兩相撞。撞完放回。求撞完了所有石頭剩下的最小重量

> 具體問題具體分析。
> 不要他媽真的去撞，站在更高的角度去思考，將石頭分成兩半，這是一個二分子集問題
> 所以先搜索自己的知識庫，找找能不能轉化出去。
> 最問題在算法題裏不一定要搜索，還有可能轉化。
> 編輯距離看起來也是可以轉化的。




# 目標和

添加加減運算符，凑目標和。返回組合方法。

本質就是最後一塊石頭。只是對最後撞完剩下的值有要求。

> 然後就要計算正數和負數的集合。找到正數或者負數的值。

令正數集合為`l`，負數集合為`r`。
`l - r = target,l + r = sum`。
於是，`l = (target + sum) / 2`

這就是背包的容量。

> 有多少種方式裝滿背包？


1. `dp[j]` 為裝滿容量j的背包的`dp[j]` 種辦法
2. `dp[j] += dp[j - nums[i]]`, `nums[i]`是第i個物品的重量。`j - nums[i]`代表有`nums[i]`物品后有多少種辦法。注意這裏是辦法，所以不需要`+1`，跟有多少種路徑也是一樣的。直接找到到`dp[j-nums[i]]`找到更小規模的即可。
3. `dp[0]=1`，取容量為0的背包有1種辦法。`dp[j]=0`。因爲是纍加，不初始為0就會有重複纍加問題。
4. 遍歷順序
```cpp
for(int j = 0;j < nums.size();j++){
	for(int i = bagSize;j >= nums[i];j--){
	}
}
```

# 1和0-多维背包

二維背包
找到子集，共有m個0，n個1。

1. `dp[i][j]`表示裝滿i個0和j個1需要`dp[i][j]`個物品
2. 