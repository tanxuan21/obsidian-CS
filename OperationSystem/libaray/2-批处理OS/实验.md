

## 对比LibOS


|     | LibOS    | 批处理OS     |
| --- | -------- | --------- |
| 隔离  | 硬件-应用    | APP-OS    |
| 目标  | 简化访问硬件难度 | 自动加载多应用程序 |
## 启动项目
```shell
git clone user
git checkout ch2
make test
```

看到添加了仓库user。这里放用户程序。
makefile更改了关于用户程序的编译部分。
## 应用程序加载
用户的程序保存在变量
```asm
.global _app_num
```

里。这个变量在`OS/link_app.S`里。
在`OS/loader.c`函数`loader_init`里，获取到app数。

```C
#ifndef BATCH_H
#define BATCH_H

#include "const.h"
#include "types.h"

void loader_init();
int run_next_app();
  

#define BASE_ADDRESS (0x80400000)
#define MAX_APP_SIZE (0x20000)
#define USER_STACK_SIZE PAGE_SIZE
#define TRAP_PAGE_SIZE PAGE_SIZE

#endif // BATCH_H
```
可以看到这里有很多的初始化代码。
为什么要有两个栈？为了安全！
## 特权级切换

CSR(control and status register)控制状态寄存器存储特权状态。


| CSA名     | 功能                                   |
| -------- | ------------------------------------ |
| sstatus  | 其中的spp字段记录CPU特权级                     |
| sepc     | Trap发生前最后一条指令地址，产生Trap的指令地址          |
| scause   | Trap原因                               |
| stval    | Trap附加信息，相当于scause的备注。比如缺页错误，记录缺页的地址 |
| stvec    | Trap处理代码的入口地址                        |
| sscratch | 内核栈（用户栈）地址                           |
- CPU将当前的特权级设置为S
- 跳到stvec所设置的Trap处理入口地址
- 切换栈

### 代码：

[资料](https://rcore-os.cn/rCore-Tutorial-deploy/docs/lab-1/guide/part-2.html)
#### trampoline.s
里面的全局变量
```asm
.globl trampoline
```
定义了切换内核态和用户态的汇编程序。
下面两个具体的程序给出了保存trap上下文的程序
```asm
.globl uservec
.globl userret
```
> 这里他妈的这么绕吗，让我以后再研究它
>  研究完了，在后文。
#### CPU状态寄存器

定义了sstatus寄存器的值：
os/riscv.h
```C
#define SSTATUS_SPP (1L << 8) // Previous mode, 1=Supervisor, 0=User
#define SSTATUS_SPIE (1L << 5) // Supervisor Previous Interrupt Enable
#define SSTATUS_UPIE (1L << 4) // User Previous Interrupt Enable
#define SSTATUS_SIE (1L << 1) // Supervisor Interrupt Enable
#define SSTATUS_UIE (1L << 0) // User Interrupt Enable
```

这个函数读取CPU状态寄存器的值。
os/riscv.h
```c
static inline uint64 r_sstatus()
```

#### trap and trapreturn
管理trap的OS代码在trap.c文件里。
用户态陷入内核：
```c
void usertrap(struct trapframe *trapframe)
```

trapframe结构体：
- `kernel_satp`：内核页表的起始地址。
- `kernel_sp`：进程内核栈的顶部地址。
- `kernel_trap`：用户陷阱处理函数的地址。
- `epc`：保存的用户程序计数器（PC）的值，即发生异常或中断时的指令地址。
- `kernel_hartid`：保存的内核线程ID。
- `ra`：返回地址寄存器的值。
- `sp`：堆栈指针寄存器的值。
- `gp`：全局指针寄存器的值。
- `tp`：线程指针寄存器的值。
- `t0` - `t6`：临时寄存器的值。
- `s0` - `s11`：保存的寄存器的值。
- `a0` - `a7`：函数调用参数和返回值寄存器的值。
- `s2` - `s11`：保存的寄存器的值。
- `t3` - `t6`：临时寄存器的值。

内核态回到用户态
```c
void usertrapret(struct trapframe *trapframe, uint64 kstack)
```
都是对应的将数据寄存器数据存到trapframe里，修改标志权限的寄存器值，标志指令地址的值等等。代码我大概看得懂。我不在这里写了。

> sscratch到底是存什么的？
> sscratch什么时候存内核栈顶？
> 存内核栈顶，存用户栈顶，存trapframe指针?

> 应用程序执行完毕后，run_next_app什么时候执行？也就是谁调用的run_next_app?
> 我在系统调用李看到了sys_exit里面调用了run_next_app。我猜测它跟sret一样，不用我管。






#### trampline.s详解

|  taskFrame项   |  值  | U/M |
| :-----------: | :-: | :-: |
|  kernel_satp  |     |  M  |
|   kernel_sp   |     |  M  |
|  kernel_trap  |     |  M  |
|      epc      |     |  M  |
| kernel_hartid |     |  M  |
|      ra       |     |  U  |
|      sp       |     |  U  |
|      gp       |     |  U  |
|      tp       |     |  U  |
|      t0       |     |  C  |
|      t1       |     |  C  |
|      t2       |     |  C  |
|      s0       |     |  C  |
|      s1       |     |  C  |
|      a0       |     |  C  |
|      a1       |     |  C  |
|      a2       |     |  C  |
|      a3       |     |  C  |
|      a4       |     |  C  |
|      a5       |     |  C  |
|      a6       |     |  C  |
|      a7       |     |  C  |
|      s2       |     |  C  |
|      s3       |     |  C  |
|      s4       |     |  C  |
|      s5       |     |  C  |
|      s6       |     |  C  |
|      s7       |     |  C  |
|      s8       |     |  C  |
|      s9       |     |  C  |
|      s10      |     |  C  |
|      s11      |     |  C  |
|      t3       |     |  C  |
|      t4       |     |  C  |
|      t5       |     |  C  |
|      t6       |     |  C  |

# 陷入

0. 开始：

|  寄存器项目   |       值       |     | trapframe项目 |  值  |
| :------: | :-----------: | --- | :---------: | :-: |
| sscratch | 用户trapframe地址 |     |             |     |
|    a0    |     某个地址      |     |     a0      |  ？  |
|    其他    |     用户相关      |     |     其他      |  ？  |
|    t0    |     用户相关      |     |     t0      |  ?  |
1. `csrrw a0, sscratch, a0`交换sscratch a0值

|  寄存器项目   |         值         |     | trapframe项目 |  值  |
| :------: | :---------------: | --- | :---------: | :-: |
| sscratch |     **某个地址**      |     |             |     |
|    a0    | **用户trapframe地址** |     |     a0      |  ？  |
|    其他    |       用户相关        |     |     其他      |  ？  |
|    t0    |       用户相关        |     |     t0      |  ?  |
2. 以a0为基地址，将其他寄存器的值写入trapframe内。a0就是trapframe地址。

|  寄存器项目   |       值       |     | trapframe项目 |    值     |
| :------: | :-----------: | --- | :---------: | :------: |
| sscratch |     某个地址      |     |             |          |
|    a0    | 用户trapframe地址 |     |     a0      |    ？     |
|    其他    |   **用户相关**    |     |     其他      | **用户相关** |
|    t0    |   **用户相关**    |     |     t0      | **用户相关** |
3. `csrr t0,sscratch`将sscratch读入t0

|  寄存器项目   |       值       |     | trapframe项目 |  值   |
| :------: | :-----------: | --- | :---------: | :--: |
| sscratch |   **某个地址**    |     |             |      |
|    a0    | 用户trapframe地址 |     |     a0      |  ？   |
|    其他    |     用户相关      |     |     其他      | 用户相关 |
|    t0    |   **某个地址**    |     |     t0      | 用户相关 |
4. `sd t0,112(a0)`将用户的a0值（现在在t0里）存入trapframe的a0

|  寄存器项目   |       值       |     | trapframe项目 |  值   |
| :------: | :-----------: | --- | :---------: | :--: |
| sscratch |   **某个地址**    |     |             |      |
|    a0    | 用户trapframe地址 |     |     a0      | 某个地址 |
|    其他    |     用户相关      |     |     其他      | 用户相关 |
|    t0    |   **某个地址**    |     |     t0      | 用户相关 |
5. 然后加载trapframe内的一些内核栈指针，内核函数指针信息进来，运行即可。

# 恢复

0. 现状

|  寄存器项目   |       值       |     | trapframe项目 |  值   |
| :------: | :-----------: | --- | :---------: | :--: |
| sscratch |     某个地址      |     |             |      |
|    a0    | 用户trapframe地址 |     |     a0      | 某个地址 |
|    其他    |     内核相关      |     |     其他      | 用户相关 |
|    t0    |     内核相关      |     |     t0      | 用户相关 |
1. `ld t0,112(a0)`读取a0到t0

|  寄存器项目   |       值       |     | trapframe项目 |    值     |
| :------: | :-----------: | --- | :---------: | :------: |
| sscratch |     某个地址      |     |             |          |
|    a0    | 用户trapframe地址 |     |     a0      | **某个地址** |
|    其他    |     内核相关      |     |     其他      |   用户相关   |
|    t0    |   **某个地址**    |     |     t0      |   用户相关   |
2. `csrw sscratch, t0`

|  寄存器项目   |       值       |     | trapframe项目 |  值   |
| :------: | :-----------: | --- | :---------: | :--: |
| sscratch |   **某个地址**    |     |             |      |
|    a0    | 用户trapframe地址 |     |     a0      | 某个地址 |
|    其他    |     内核相关      |     |     其他      | 用户相关 |
|    t0    |   **某个地址**    |     |     t0      | 用户相关 |
3. 基于a0将trapframe写入寄存器，除了a0自己

|  寄存器项目   |       值       |     | trapframe项目 |    值     |
| :------: | :-----------: | --- | :---------: | :------: |
| sscratch |   **某个地址**    |     |             |          |
|    a0    | 用户trapframe地址 |     |     a0      |   某个地址   |
|    其他    |   **用户相关**    |     |     其他      | **用户相关** |
|    t0    |   **用户相关**    |     |     t0      | **用户相关** |
|          |               |     |             |          |
4. 交换a0,sscratch

|  寄存器项目   |        值        |     | trapframe项目 |  值   |
| :------: | :-------------: | --- | :---------: | :--: |
| sscratch | **trapframe地址** |     |             |      |
|    a0    |    **某个地址**     |     |     a0      | 某个地址 |
|    其他    |      用户相关       |     |     其他      | 用户相关 |
|    t0    |      用户相关       |     |     t0      | 用户相关 |
问题：
为什么要t0的帮助？
可能只有t0允许读入内存

现在很清晰了。两段操作纯纯镜像。